exists
SELECT * FROM employees where not exists (select emp_no from dept_emp where dept_emp.emp_no = employees.emp_no )


Exists的用法：

exists对外表用loop逐条查询，每次查询都会查看exists的条件语句，当 exists里的条件语句能够返回记录行时(无论记录行是的多少，只要能返回)，条件就为真，返回当前loop到的这条记录;反之如果exists里的条 件语句不能返回记录行，则当前loop到的这条记录被丢弃，exists的条件就像一个bool条件，当能返回结果集则为true，不能返回结果集则为 false。
慎用Exists( ！= )

总的来说，如果外表有n条记录，那么exists查询就是将这n条记录逐条取出，然后判断n遍exists条件
如果使用：

select * from employees
where  exists( select emp_no from dept_emp where dept_emp.emp_no != employees.emp_no)
那么，Exists都会从外表employees里面逐条比对，如，第一条的emp_no = '10001'，那么
Exists判断：

select emp_no from dept_emp where dept_emp.emp_no !='10001'
可想而知，一定存在不等于10001的结果集。那么上面的查询语句其实也就等效于：

select * from employees



case else语句
select e.emp_no,e.first_name,e.last_name,b.btype,s.salary,
(case b.btype
when 1 then s.salary*0.1
when 2 then s.salary*0.2
else s.salary*0.3 end) as bonus
from employees e inner join emp_bonus b on e.emp_no=b.emp_no inner join salaries s on
s.emp_no=e.emp_no



常用函数
 
字符函数
length('abc') --- 3 长度
concat('xuan','-','yifan') --- xuan-yifan 拼接字符串
upper() lower() 大小写
substr('adcdef',3)--- cdef  sql语句中sub下标是从1开始 不同于java中的0开始
substr('adcdef',1,3)--- abc
instr('abcabedsadc','adc') --- 返回字串在主串中的下标 1 当有多个时 返回第一个 无时返回0
trim('   a    ')--- a 
trim('a' from 'aaaaaaaaa8a88aaaaa')---8a88   去除a 只去前后 中间的a为有效值 不去
lpad('xuan',6,'*')--- **xuan 左填充  lpad('xuan',3,'*')  --- xua 填充 不足长度的补齐 低于长度从左截取
rpad('xuan',6,'*')--- xuan** 左填充  rpad('xuan',3,'*')  --- xua
replace('abcdefag','a','8')--8bcdef8g 全部替换
