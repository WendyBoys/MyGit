主启动类 加注解 @EnableScheduling 开启定时任务功能


 @Scheduled(cron = "*/2 * * * * ?")  2s执行一次
    public void timer()
    {
        System.out.println("666666");
    }


注意******
多个任务时 由于默认是单线程执行 会出现很大的问题 

    @Scheduled(cron = "*/3 * * * * ?")

    public void timer1()
    {
        Thread t = Thread.currentThread();
        System.out.println("taskSchule1 "+ new Date().toLocaleString() +" ThreadID:"+  t.getId() +" "+t.getName());
    }

    @Scheduled(cron = "*/10 * * * * ?")

    public void timer2()
    {
        Thread t = Thread.currentThread();
        System.out.println("taskSchule2 begin "+ new Date().toLocaleString() +" ThreadID:"+  t.getId() +" "+t.getName());
        try {
            Thread.sleep(8000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("taskSchule2  end"+ new Date().toLocaleString() +" ThreadID:"+  t.getId() +" "+t.getName());

    }



第一个坑
因为Spring中@EnableScheduling和@Scheduled标注的定时任务默认是单线程执行的，这里任务2执行任务需要花费超过8s的较长时间，所以阻塞了任务1的执行 任务1不会每3s执行一次 事实上会达到很多秒才执行一次 严重影响业务。


解决方案：使用@Async和@EnableAsync异步执行任务
事实上在Spring的定时任务包中提供了@EnableAsync和@Async注解用于多线程异步执行任务。
首先在启动类上添加@EnableAsync注解，并在TestSchedule类上标注@Async注解，表示该类中所有标注了@Scheduled的方法都使用异步处理方式。

此时，任务1和任务2均运行正常，并且任务1和任务2都是不同线程在执行，不会出现任务之间相互阻塞的情况。
这里是解决了第一个坑的问题，但是实际上可能引入第二个坑。

第二个坑

这里我们稍作修改将任务2的睡眠时间改成11秒 Thread.sleep(11000);，此时任务2的执行时间已经超过了它的调度时间。再次运行程序：
观察发现任务1正常执行，但是任务2中a、b和c、d两组出现了交叉，两组是不同线程执行的，因为任务2的执行时间超过了调度时间，所以，a处开始执行，在未执行完成的情况下，任务的调度时间到了，其他线程有立马调度了任务从c处开始执行。
这是使用@EnableAsync和@Async可能会出现的问题。

解决方案
去掉@EnableAsync和@Async注解，去掉@EnableScheduling注解 
创建一个任务配置类ScheduleConfig 实现SchedulingConfigurer接口的configureTasks方法，使用参数taskRegistrar为任务调度创建线程池

@Configuration
@EnableScheduling
public class ScheduleConfig implements SchedulingConfigurer {

   
 @Override
   
 public void configureTasks(ScheduledTaskRegistrar taskRegistrar)
 {
    
    taskRegistrar.setScheduler(taskExecutor());
  
  }

   
 @Bean(destroyMethod="shutdown")
   
 public Executor taskExecutor() {
   
     return Executors.newScheduledThreadPool(10);
  
  }

}

完美解决坑一加坑二！！！

总结 ：
SpringBoot中可以使用@EnableScheduling和@Scheduled注解实现定时任务调度，但是注意默认所有任务都被单个线程调度的，有可能任务之间发生阻塞现象，可以使用@EnableAsync和@Async注解实现异步多线程任务调度，但需要注意任务执行时间如果大于任务调度周期时间，可能出现同一个任务交叉执行的情况



cronExpression定义时间规则，Cron表达式由6或7个空格分隔的时间字段组成：秒 分钟 小时 日期 月份 星期    年（可选）；

字段　　允许值　　允许的特殊字符
秒     　 0-59 　　　　, - * /
分     　 0-59　　　　 , - * /
小时      0-23 　　　　, - * /
日期      1-31 　　　　, - * ? / L W C
月份      1-12 　　　　, - * /
星期      1-7 　　　　  , - * ? / L C #
年     1970-2099 　　, - * /

解析：
0/5 * * * * ? ： 每5秒执行一次

“*”字符被用来指定所有的值。如："*"在分钟的字段域里表示“每分钟”。
“?”字符只在日期域和星期域中使用。它被用来指定“非明确的值”。当你需要通过在这两个域中的一个来指定一些东西的时候，它是有用的。看下面的例子你就会明白。
月份中的日期和星期中的日期这两个元素时互斥的一起应该通过设置一个问号来表明不想设置那个字段。

“-”字符被用来指定一个范围。如：“10-12”在小时域意味着“10点、11点、12点”。

“,”字符被用来指定另外的值。如：“MON,WED,FRI”在星期域里表示”星期一、星期三、星期五”。

“/”字符用于指定增量。如：“0/15”在秒域意思是每分钟的0，15，30和45秒。“5/15”在分钟域表示每小时的5，20，35和50。 符号“*”在“/”前面（如：*/10）等价于0在“/”前面（如：0/10）。记住一条本质：表达式的每个数值域都是一个有最大值和最小值的集合，如： 秒域和分钟域的集合是0-59，日期域是1-31，月份域是1-12。字符“/”可以帮助你在每个字符域中取相应的数值。如：“7/6”在月份域的时候只 有当7月的时候才会触发，并不是表示每个6月。

L是‘last’的省略写法可以表示day-of-month和day-of-week域，但在两个字段中的意思不同，例如day-of- month域中表示一个月的最后一天。如果在day-of-week域表示‘7’或者‘SAT’，如果在day-of-week域中前面加上数字，它表示 一个月的最后几天，例如‘6L’就表示一个月的最后一个星期五。

字符“W”只允许日期域出现。这个字符用于指定日期的最近工作日。例如：如果你在日期域中写 “15W”，表示：这个月15号最近的工作日。所以，如果15号是周六，则任务会在14号触发。如果15好是周日，则任务会在周一也就是16号触发。如果 是在日期域填写“1W”即使1号是周六，那么任务也只会在下周一，也就是3号触发，“W”字符指定的最近工作日是不能够跨月份的。字符“W”只能配合一个 单独的数值使用，不能够是一个数字段，如：1-15W是错误的。

“L”和“W”可以在日期域中联合使用，LW表示这个月最后一周的工作日。

字符“#”只允许在星期域中出现。这个字符用于指定本月的某某天。例如：“6#3”表示本月第三周的星期五（6表示星期五，3表示第三周）。“2#1”表示本月第一周的星期一。“4#5”表示第五周的星期三。

字符“C”允许在日期域和星期域出现。这个字符依靠一个指定的“日历”。也就是说这个表达式的值依赖于相关的“日历”的计算结果，如果没有“日历” 关联，则等价于所有包含的“日历”。如：日期域是“5C”表示关联“日历”中第一天，或者这个月开始的第一天的后5天。星期域是“1C”表示关联“日历” 中第一天，或者星期的第一天的后1天，也就是周日的后一天（周一）。

例子如下：

0 0 10,14,16 * * ? 每天上午10点，下午2点，4点
0 0/30 9-17 * * ?   朝九晚五工作时间内每半小时
0 0 12 ? * WED 表示每个星期三中午12点
"0 0 12 * * ?" 每天中午12点触发 
"0 15 10 ? * *" 每天上午10:15触发 
"0 15 10 * * ?" 每天上午10:15触发 
"0 15 10 * * ? *" 每天上午10:15触发 
"0 15 10 * * ? 2005" 2005年的每天上午10:15触发 
"0 * 14 * * ?" 在每天下午2点到下午2:59期间的每1分钟触发 
"0 0/5 14 * * ?" 在每天下午2点到下午2:55期间的每5分钟触发 
"0 0/5 14,18 * * ?" 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发 
"0 0-5 14 * * ?" 在每天下午2点到下午2:05期间的每1分钟触发 
"0 10,44 14 ? 3 WED" 每年三月的星期三的下午2:10和2:44触发 
"0 15 10 ? * MON-FRI" 周一至周五的上午10:15触发 
"0 15 10 15 * ?" 每月15日上午10:15触发 
"0 15 10 L * ?" 每月最后一日的上午10:15触发 
"0 15 10 ? * 6L" 每月的最后一个星期五上午10:15触发 
"0 15 10 ? * 6L 2002-2005" 2002年至2005年的每月的最后一个星期五上午10:15触发 
"0 15 10 ? * 6#3" 每月的第三个星期五上午10:15触发



在线生成cron表达式网站  https://cron.qqe2.com/